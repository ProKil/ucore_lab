# Lab2 Report

计43 高童 2014011357

## 练习一：First-Fit Mem Alloc

本练习要求实现 First-Fit 物理内存分配算法。主要函数的实现思路如下：

`default_init_memmap()`函数初始化一个自由块。对于这个块内的每个页，需要把它的标志位正确设置，随后加入`free_list`中。由于空闲页块组成环形链表，所以可以采用`list_add_before(&free_list, &(p->page_link));`的办法将所有页从小到大装入表中。最后，不能忘记设置`base`的`property`属性为整个块的大小。

`default_alloc_pages()`函数给你返回符合要求页块的首地址。只需要从`free_list`开始搜索，检查`property`属性，如果大于等于需要分配的页数，空闲块就可以分配给应用。但如果`property`属性**大于**需要分配的页数，那最后剩下的**外碎片**也需要自己组成一个空闲块，需要编辑其首页的相关属性。

`default_free_pages()`函数将释放的页重新加入`free_list`中。首先，需要从表头开始搜索，找到被释放页在表中的位置，随后把被释放的页重新加入表中。之后，把`base`的`property`属性设置为`n`，代表这一段内存重新空闲。最后，检查这段内存的前后是不是空闲块，如果是需要进行合并。如果前面是空闲块的话，由于不知道前面这块有多大，所以要一个一个页地向前移动，知道找到空闲块的第一个页。

**和`answer`实现的区别：**

由于对实验要求不熟悉，我在编程前先参考了`answer`。在完成后，内容大同小异，但我因为查阅了程序`memlaylou.h`中关于`PG_property`的相关注释，所以在`default_free_pages()`合并空闲块时设置了`SetPageProperty(base);`和`ClearPageProperty(base);`标志位。后来查阅实验指导书得知，Property标志位在本实验中**仅代表**“是否空闲”，**不代表**“是否是空闲块第一页”，因此我删除了相关语句。

**进一步改进空间：**

可以在一整个空闲块中的**最后一页**里也存储一下**块的大小**。这样，在和前面的空闲块合并时，不用一个一个页地向前移动，直接在物理页上做减法即可。这样可以和“和后面的空闲块合并”做到一样快速。

## 练习二：页表项查找

当内核其他部分查找某一线性地址的页表项（PTE）时，会调用`get_pte()`函数。函数**首先**会在页目录（PDT）中找到对应项（PDE）查到二级页表（PT）地址，**随后**在二级页表中查找这个页表项（PTE）。按照注释提示，实现步骤如下：

1. 通过运用`PDX(la)`宏在页目录表中找到这个线性地址对应的PDE。
2. 检查其存在位，如果存在，直接记录PT位置；
3. 如果不存在：
   1. 检查是否需要创建之，如果不需要直接返回NULL；
   2. 如果需要，则给这个PT分配一个页。如果已无法分配，也返回NULL；
   3. 如果分配成功，设置这一页的reference，同时用`memset`将页初始化为0；
   4. 设置之前PDE的内容为PT的物理地址，同时设置标志位。
4. 最后在PT中用`PTX(la)`宏查找到PTE的位置，返回之。

**和`answer`实现的区别：**

实验实现和`answer`中的实现相似。在处理两个返回NULL的情况时，本实验实现分成了两次判断，查看`create`参数后才创建新页，节省了一次可能的`struct Page *p`过程，节省了空间、优化了逻辑。

**请描述页目录项（PDE）和页表项（PTE）中每个组成部分的含义和以及对ucore而言的潜在用处。**

这些组成部分的含义可见`mmu.h`中相关宏的定义。

对PDE：

- 第0位：Present，表示这个PDE对应的页表是否存在，如果不在需要新建此页表。
- 第1位：Writable，表示这个PDE对应的页表内容是否可写；可以用作权限控制，比如对所有代码部分此位为0。
- 第2位：User can access，表示页表内容是否可被用户访问；同样用作用户态和内核态的权限控制，内核态代码数据可置为0。
- 第3位：Write-through，表示此页在改变时是否直接写回。
- 第4位：Cache-disabled，表示是否禁用Cache？目前实验尚未用到。
- 第5位：Accessed，表示这个PDE是否被访问过；可能用在页替换算法中，选择需要替换的页。
- 第12-31位：表示此PDE对应PT的物理地址的第12-31位；用户PDE到PTE的查询。

对PTE：

- 第0-5位：同PDE。
- 第6位：Dirty，脏位，表示此页中是否有未写会的修改。在不是Write-through时，如果此页被替换，需要先把修改过的内容写回物理内存，保证一致性。
- 第12-31位：表示此页物理地址的第12-31位；直接的页表查询内容。

**如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？**

系统发出缺页异常请求，随后由MMU负责将所缺页面从外存加载到内存中。

如果内存已满，则执行页替换算法，选择一个页替换。如果没有采用写直达方法，而此页已被修改过，则先要把被替换的页写回外存。

在替换完成后，将原先那个页在页表中的驻留位改为0，将新加进来的页加回到页表中。

最后，重新执行产生缺页异常的语句。

## 练习三：释放物理页

当需要释放某个物理页时，需要将此页的reference值减一；如果减到0，则需要将此页释放。然后把页表中的这一项删去。最后，需要更新TLB中相关内容。按照注释提示，实现步骤如下：

1. 检查此页是否在页表内。如果不在，就不需要释放；
2. 通过`pte2page`找到页表（PTE）项对应的物理页；
3. 如果将reference值减一后已经减到零，则将此页释放；
4. 将此页表项整个置0；
5. 最后，调用`tlb_invalidate`更新TLB。

**和`answer`实现的区别：**

由于注释清晰、步骤简单，实现和`answer`没有什么大的区别。

**数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？**

整个页目录（PDT）在一个Page内存储。每个页目录项（PDE）指向一个页表，这个页表在一个Page内存储，所以PDE和Page一一对应。而每个页表项（PTE）自然也指向一个页，所以也和Page一一对应。

**如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？**

只需要将`memlayout.h`中的宏`KERNBASE`改为0即可。

## 本实验知识点

- 物理内存的管理方法（连续物理内存的管理）
- 基于段页式内存地址的转换机制
- 页表的建立和使用方法

## 本实验中未直接体现的知识点

- 地址检查
- 物理内存的探测方法
- 反置页表