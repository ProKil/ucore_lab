# Lab6 Report

计43 高童 2014011357

## 练习零：修改已有实验

**对LAB1的修改：**

每当系统时钟时，需要调用调度程序的`sched_class_proc_tick()`函数，让调度程序知道当前程序已经运行了一个时钟周期。因此在处理时钟中断时改为：

```C
my_sched_class_proc_tick(current);
```

由于原函数为静态类型，因此在实现时采用了自己实现的接口。

**对LAB4的修改：**

在初始化进程控制块时，要新增初始化内容：

```C
proc->rq = NULL;
list_init(&(proc->run_link));
proc->time_slice = 0;
skew_heap_init(&(proc->lab6_run_pool));
proc->lab6_stride = 0;
proc->lab6_priority = 0;
```

**和`answer`实现的区别：**

在修改LAB4时，直接采用了uCore定义的`skew_heap_init()`函数，比答案更简化了初始化实现。

## 练习1: 使用 Round Robin 调度算法

**理解并分析`sched_calss`中各个函数指针的用法，并描述ucore的调度执行过程？**

`sched_class`类维护了就绪队列，每次调度时，会从队列中选一个进程执行。除了指示名字的字符串外，还有五个函数指针，分别是：

- `init()`，用于在在一开始初始化调度器类；
- `enqueue()`，会将某一个进程加入就绪队列；
- `pick_next()`，会用算法固定的方法，从就绪队列中选出接下来要运行的进程；
- `dequeue()`，会将某一个进程移出就绪队列；
- `proc_tick()`，在每个时钟周期都调用，让调度算法知道过去了一个时钟周期，以在合适时机设立调度标志位。

LAB6中，`schedule()`函数的调度点包括：

- `do_exit()`，进程主动退出时；
- `do_wait()`，进程主动放弃CPU等待时；
- `init_main()`，initproc线程等待所有用户进程结束；
- `cpu_idle()`，idleproc进程，如果有就绪进程就切换之；
- `lock()`，如果得不到锁，则放弃CPU；
- `trap()`，修改时间片，如果看到调度标志位，则调度之。

LAB6中，`schedule()`函数的实现如下：

```C
void
schedule(void) {
    bool intr_flag;
    struct proc_struct *next;
    local_intr_save(intr_flag);
    {
        current->need_resched = 0;
        if (current->state == PROC_RUNNABLE) {
            sched_class_enqueue(current);
        }
        if ((next = sched_class_pick_next()) != NULL) {
            sched_class_dequeue(next);
        }
        if (next == NULL) {
            next = idleproc;
        }
        next->runs ++;
        if (next != current) {
            proc_run(next);
        }
    }
    local_intr_restore(intr_flag);
}
```

大致思路如下（整体在禁用中断时实现）：

1. 如果当前进程`current`依然是`PROC_RUNNABLE`状态，则将之加入就绪队列；
2. 开始选取下一个进程`next`。调用pick_next接口，如果不为空，则将之设为`next`；如果为空，将`idleproc`设置为`next`；
3. 将`next`的运行次数加1，可能在部分调度算法中有用；
4. 如果下一个进程和当前进程不同，调用`proc_run()`，执行进程切换。

**如何设计实现“多级反馈队列调度算法”？**

修改调度算法的实现如下：

1. 当执行`init()`时，初始化多个就绪队列，组成一个`run_queue`类型数组；
2. 当执行`enqueue()`时，检查程序的`proc->runs`，如果为0，则将之放入第一个队列，若为1，则放入第二个，以此类推。对不同的队列初始化不同的`proc->timeslice`值；
3. 当执行`pick_next()`时，从最高优先级队列开始寻找，只有找不到时才到低一级队列寻找；
4. 当执行`pick_next()`时，寻找所有队列中的匹配；
5. `proc_tick()`不用修改。

## 本实验知识点



## 本实验中未直接体现的知识点

