# Lab1 Report

计43 高童 2014011357

## 练习一

**一、操作系统镜像文件ucore.img是如何一步一步生成的？**
(1) **编译源文件**。用`i386-elf-gcc`编译所有原始C程序文件、原始汇编程序文件到`.o`文件。其中一个样例为：

```bash
i386-elf-gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o
```

其中的编译参数的含义为：

- `-I`选项指定了头文件寻找目录;
- `-g`选项生成调试信息；
- `-nostdinc`禁止搜索标准头文件，减小操作系统大小；
- `-fno-builtin`让编译器不识别内置函数，减小操作系统的大小；
- `-fno-stack-protector`让编译器不添加栈保护代码，让我们执行更多栈操作；
- `-Wall`使编译器显示所有警告，使我们可以改正错误；
- `-m32`生成32位机器运行的机器码。

(2) **链接`.o`文件**。用`i386-elf-ld`链接之前编译成功的`.o`文件，分别生成操作系统内核`kernel`和bootloader文件内容`bootblock`。分别考察之，链接生成`kernel`的代码为：

```bash
i386-elf-ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o
```

其中的链接参数的含义为：

- `-m elf_i386`选项指定了仿真平台;
- `-nostdinc`禁止链接标准头文件，减小操作系统大小；
- `-T`指定了链接脚本。

链接生成`bootblock`的代码为：

```BASH
i386-elf-ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
'obj/bootblock.out' size: 484 bytes
build 512 bytes boot sector: 'bin/bootblock' success!
```

其中的链接参数的含义为：

- `-N`指定链接后代码和数据可读写；
- `-e start`让链接器将`start`标签作为入口。

(3) **生成虚拟硬盘**。用`dd`先生成一个空硬盘`ucore.img`，再分别将`bootblock`和`kernel`写入硬盘。

```bash
dd if=/dev/zero of=bin/ucore.img count=10000
10000+0 records in
10000+0 records out
5120000 bytes transferred in 0.027234 secs (188001405 bytes/sec)

dd if=bin/bootblock of=bin/ucore.img conv=notrunc
1+0 records in
1+0 records out
512 bytes transferred in 0.000123 secs (4161790 bytes/sec)

dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
138+1 records in
138+1 records out
70696 bytes transferred in 0.000276 secs (256062621 bytes/sec)
```

其中的参数的含义为：

- `if`和`of`分别指定了输入和输出文件；
- 在写入`kernel`时，`seek=1`参数让`dd`跳过第一个扇区（bootloader扇区）后从第二个扇区开始写入。

**二、一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？**

通过阅读`sign.c`文件中的以下代码：

```c
char buf[512];
memset(buf, 0, sizeof(buf));
FILE *ifp = fopen(argv[1], "rb");
int size = fread(buf, 1, st.st_size, ifp);
// ...
fclose(ifp);
buf[510] = 0x55;
buf[511] = 0xAA;
FILE *ofp = fopen(argv[2], "wb+");
size = fwrite(buf, 1, 512, ofp);
```

可以知道一个符合规范的主引导扇区的最后两个字节（也就是第511、512个字节）应该分别为`0x55`和`0xAA`。

## 练习二

**一、从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。**

由于本练习不牵涉到uCore，在Eclipse-CDT环境中不发挥优势，因此只通过命令行形式完成。首先在一个Terminal窗口中执行：

```bash
qemu-system-i386 -S -s -d in_asm -D bin/q.log -monitor stdio -hda bin/ucore.img -serial null
```

表示通过QEMU运行虚拟硬盘`bin/ucore.img`中的操作系统。参数`-s`和`-s`让QEMU不会自动执行，而会等待`gdb`的远程连接。

随后，在第二个Terminal窗口中执行：

```bash
i386-elf-gdb -q
```

打开`gdb`，随后在`gdb`中输入：

```gdb
file bin/kernel
target remote :1234
set architecture i8086
b* 0x7c00
continue
```

就可通过1234端口连接QEMU，并在`gdb`中远程调试虚拟机。之后的单步调试只需要执行`nexti`或者`stepi`即可。

**二、在初始化位置0x7c00设置实地址断点，测试断点正常。**

在步骤一中已经实现。

**三、从0x7c00开始跟踪代码运行，将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。**

在调用QEMU时增加参数`-d in_asm -D q.log`便可以定向把汇编内容记录到q.log里。

跟踪到的反汇编代码为：

```assembly
IN: 
0x00007c00:  cli    
----------------
IN: 
0x00007c00:  cli    
----------------
IN: 
0x00007c01:  cld    
0x00007c02:  xor    %ax,%ax
0x00007c04:  mov    %ax,%ds
0x00007c06:  mov    %ax,%es
0x00007c08:  mov    %ax,%ss
----------------
IN: 
0x00007c0a:  in     $0x64,%al
----------------
IN: 
0x00007c0c:  test   $0x2,%al
0x00007c0e:  jne    0x7c0a
----------------
IN: 
0x00007c10:  mov    $0xd1,%al
0x00007c12:  out    %al,$0x64
0x00007c14:  in     $0x64,%al
0x00007c16:  test   $0x2,%al
0x00007c18:  jne    0x7c14
----------------
IN: 
0x00007c1a:  mov    $0xdf,%al
0x00007c1c:  out    %al,$0x60
0x00007c1e:  lgdtw  0x7c6c
0x00007c23:  mov    %cr0,%eax
0x00007c26:  or     $0x1,%eax
0x00007c2a:  mov    %eax,%cr0
----------------
IN: 
0x00007c2d:  ljmp   $0x8,$0x7c32
----------------
IN: 
0x00007c32:  mov    $0x10,%ax
0x00007c36:  mov    %eax,%ds
----------------
IN: 
0x00007c38:  mov    %eax,%es
----------------
IN: 
0x00007c3a:  mov    %eax,%fs
0x00007c3c:  mov    %eax,%gs
0x00007c3e:  mov    %eax,%ss
----------------
IN: 
0x00007c40:  mov    $0x0,%ebp
----------------
IN: 
0x00007c45:  mov    $0x7c00,%esp
```

与bootasm.S和 bootblock.asm中的代码相同。

**四、自己找一个bootloader或内核中的代码位置，设置断点并进行测试。**

在`gdb`中输入`b *0x7c0c`再输入`c`，即会发现程序停在`0x7c0c`位置，断点测试通过。

## 练习三

**请分析bootloader是如何完成从实模式进入保护模式的。**

在进入保护模式的过程中，主要执行了一下三个步骤：

**一、开启A20**

为了兼容早期8086CPU，因特尔必须保持地址线“回卷”现象。为了访问较高的地址，必须开启A20，以此禁用回卷，访问更高端的地址区。A20通过键盘控制器8042控制。

从逻辑上讲，操作只需一步：将8042某个控制位置1。按照8042操作规程操，首先应该向`0x64`端口输出数据`0x1d`，随后再向`0x60`端口写入A20使能位。另外，在实际操作中为了防止冲突，首先要确认8042没有别的输入数据在缓存中，如果有则循环之后再次测试。

相关代码段如下：

```assembly
seta20.1:
    inb $0x64, %al   # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.1

    movb $0xd1, %al  # 0xd1 -> port 0x64
    outb %al, $0x64  # 0xd1 means: write data to 8042's P2 port

seta20.2:
    inb $0x64, %al   # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.2

    movb $0xdf, %al  # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
```

**二、建立全局描述符表**

在`bootasm.S`中，我们已经建立好了一个初始的GDT，只需要通过一条指令即可实现：

```assembly
lgdt gdtdesc
```

其中，`gdtdesc`是初始GDT的所在位置。GDT的格式为：

```assembly
.p2align 2                                 # force 4 byte alignment
gdt:
    SEG_NULLASM                            # null seg
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)  # code seg
    SEG_ASM(STA_W, 0x0, 0xffffffff)        # data seg
gdtdesc:
    .word 0x17                             # sizeof(gdt) - 1
    .long gdt                              # address gdt
```

可以看出数据段、代码段都覆盖了整个地址空间，这样线性地址和物理地址保持一样，使计算机在页机制开始实行前正常工作。

**三、使能并进入保护模式**

保护模式的使能位位于寄存器`%cr0`中，只需将此位使能即可。代码如下：

```assembly
    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0
```

最后，通过一条`ljmp $PROT_MODE_CSEG, $protcseg`代码，跳转入保护模式代码段。

**四、初始化保护模式寄存器，把控制权交由C程序**

保护模式寄存器包括各个段的段选择子和`%ebp`和`%esp`两个指示栈的寄存器。对他们进行初始化的代码如下：

```assembly
.code32   # Assemble for 32-bit mode
protcseg:
    # Set up the protected-mode data segment registers
    movw $PROT_MODE_DSEG, %ax       # Our data segment selector
    movw %ax, %ds                   # -> DS: Data Segment
    movw %ax, %es                   # -> ES: Extra Segment
    movw %ax, %fs                   # -> FS
    movw %ax, %gs                   # -> GS
    movw %ax, %ss                   # -> SS: Stack Segment
    # Set up the stack pointer and call into C.
    movl $0x0, %ebp
    movl $start, %esp
```

最后，通过一条`call bootmain`语句将控制权交由`bootmain`，程序正式进入保护模式。

