# Lab1 Report

计43 高童 2014011357

## 练习一

**一、操作系统镜像文件ucore.img是如何一步一步生成的？**
(1) **编译源文件**。用`i386-elf-gcc`编译所有原始C程序文件、原始汇编程序文件到`.o`文件。其中一个样例为：

```bash
i386-elf-gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o
```

其中的编译参数的含义为：

- `-I`选项指定了头文件寻找目录;
- `-g`选项生成调试信息；
- `-nostdinc`禁止搜索标准头文件，减小操作系统大小；
- `-fno-builtin`让编译器不识别内置函数，减小操作系统的大小；
- `-fno-stack-protector`让编译器不添加栈保护代码，让我们执行更多栈操作；
- `-Wall`使编译器显示所有警告，使我们可以改正错误；
- `-m32`生成32位机器运行的机器码。

(2) **链接`.o`文件**。用`i386-elf-ld`链接之前编译成功的`.o`文件，分别生成操作系统内核`kernel`和bootloader文件内容`bootblock`。分别考察之，链接生成`kernel`的代码为：

```bash
i386-elf-ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o
```

其中的链接参数的含义为：

- `-m elf_i386`选项指定了仿真平台;
- `-nostdinc`禁止链接标准头文件，减小操作系统大小；
- `-T`指定了链接脚本。

链接生成`bootblock`的代码为：

```BASH
i386-elf-ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
'obj/bootblock.out' size: 484 bytes
build 512 bytes boot sector: 'bin/bootblock' success!
```

其中的链接参数的含义为：

- `-N`指定链接后代码和数据可读写；
- `-e start`让链接器将`start`标签作为入口。

(3) **生成虚拟硬盘**。用`dd`先生成一个空硬盘`ucore.img`，再分别将`bootblock`和`kernel`写入硬盘。

```bash
dd if=/dev/zero of=bin/ucore.img count=10000
10000+0 records in
10000+0 records out
5120000 bytes transferred in 0.027234 secs (188001405 bytes/sec)

dd if=bin/bootblock of=bin/ucore.img conv=notrunc
1+0 records in
1+0 records out
512 bytes transferred in 0.000123 secs (4161790 bytes/sec)

dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
138+1 records in
138+1 records out
70696 bytes transferred in 0.000276 secs (256062621 bytes/sec)
```

其中的参数的含义为：

- `if`和`of`分别指定了输入和输出文件；
- 在写入`kernel`时，`seek=1`参数让`dd`跳过第一个扇区（bootloader扇区）后从第二个扇区开始写入。

**二、一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？**

通过阅读`sign.c`文件中的以下代码：

```c
char buf[512];
memset(buf, 0, sizeof(buf));
FILE *ifp = fopen(argv[1], "rb");
int size = fread(buf, 1, st.st_size, ifp);
// ...
fclose(ifp);
buf[510] = 0x55;
buf[511] = 0xAA;
FILE *ofp = fopen(argv[2], "wb+");
size = fwrite(buf, 1, 512, ofp);
```

可以知道一个符合规范的主引导扇区的最后两个字节（也就是第511、512个字节）应该分别为`0x55`和`0xAA`。

## 练习二

**一、从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。**

由于本练习不牵涉到uCore，在Eclipse-CDT环境中不发挥优势，因此只通过命令行形式完成。首先在一个Terminal窗口中执行：

```bash
qemu-system-i386 -S -s -d in_asm -D bin/q.log -monitor stdio -hda bin/ucore.img -serial null
```

表示通过QEMU运行虚拟硬盘`bin/ucore.img`中的操作系统。参数`-s`和`-s`让QEMU不会自动执行，而会等待`gdb`的远程连接。

随后，在第二个Terminal窗口中执行：

```bash
i386-elf-gdb -q
```

打开`gdb`，随后在`gdb`中输入：

```gdb
file bin/kernel
target remote :1234
set architecture i8086
b* 0x7c00
continue
```

就可通过1234端口连接QEMU，并在`gdb`中远程调试虚拟机。之后的单步调试只需要执行`nexti`或者`stepi`即可。

**二、在初始化位置0x7c00设置实地址断点，测试断点正常。**

在步骤一中已经实现。

**三、从0x7c00开始跟踪代码运行，将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。**

在调用QEMU时增加参数`-d in_asm -D q.log`便可以定向把汇编内容记录到q.log里。

跟踪到的反汇编代码为：

```assembly
IN: 
0x00007c00:  cli    
----------------
IN: 
0x00007c00:  cli    
----------------
IN: 
0x00007c01:  cld    
0x00007c02:  xor    %ax,%ax
0x00007c04:  mov    %ax,%ds
0x00007c06:  mov    %ax,%es
0x00007c08:  mov    %ax,%ss
----------------
IN: 
0x00007c0a:  in     $0x64,%al
----------------
IN: 
0x00007c0c:  test   $0x2,%al
0x00007c0e:  jne    0x7c0a
----------------
IN: 
0x00007c10:  mov    $0xd1,%al
0x00007c12:  out    %al,$0x64
0x00007c14:  in     $0x64,%al
0x00007c16:  test   $0x2,%al
0x00007c18:  jne    0x7c14
----------------
IN: 
0x00007c1a:  mov    $0xdf,%al
0x00007c1c:  out    %al,$0x60
0x00007c1e:  lgdtw  0x7c6c
0x00007c23:  mov    %cr0,%eax
0x00007c26:  or     $0x1,%eax
0x00007c2a:  mov    %eax,%cr0
----------------
IN: 
0x00007c2d:  ljmp   $0x8,$0x7c32
----------------
IN: 
0x00007c32:  mov    $0x10,%ax
0x00007c36:  mov    %eax,%ds
----------------
IN: 
0x00007c38:  mov    %eax,%es
----------------
IN: 
0x00007c3a:  mov    %eax,%fs
0x00007c3c:  mov    %eax,%gs
0x00007c3e:  mov    %eax,%ss
----------------
IN: 
0x00007c40:  mov    $0x0,%ebp
----------------
IN: 
0x00007c45:  mov    $0x7c00,%esp
```

与bootasm.S和 bootblock.asm中的代码相同。

**四、自己找一个bootloader或内核中的代码位置，设置断点并进行测试。**

在`gdb`中输入`b *0x7c0c`再输入`c`，即会发现程序停在`0x7c0c`位置，断点测试通过。

