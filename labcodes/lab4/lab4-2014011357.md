# Lab4 Report

计43 高童 2014011357

## 练习一：分配并初始化一个进程控制块

在`alloc_proc()`函数中，需要对进程控制块的各项内容进行初始化，通常为0或者`NULL`。除了三个域：

```c
proc->state = PROC_UNINIT;
proc->pid = -1;
proc->cr3 = boot_cr3;
```

第一项表示进程的状态，处于未配置完成的阶段。

第二项显示进程的PID目前还不合法，表示进程尚不能运行。

第三项表示进程使用内核的页表，指示其是属于“uCore内核”大线程中的进程。

**和`answer`实现的区别：**

由于对`memset`的使用不熟悉，在对`context`和`name`两个域初始化时显得过于复杂。参考答案后，改为如下：

```C
memset(&(proc->context), 0, sizeof(struct context));
memset(proc->name, 0, PROC_NAME_LEN);
```

**请说明`proc_struct`中`struct context context`和`struct trapframe *tf`成员变量含义和在本实验中的作用是啥？**

`struct context context`表示进程的上下文，即进程运行中寄存器的状态。其定义如下：

```C
struct context {
    uint32_t eip;
    uint32_t esp;
    uint32_t ebx;
    uint32_t ecx;
    uint32_t edx;
    uint32_t esi;
    uint32_t edi;
    uint32_t ebp;
};
```

说白了，`context`保存了80386的八个寄存器，包括栈顶寄存器、指令寄存器和通用寄存器等等。当切换进程时，需要切换进程的上下文，即把原进程的八个寄存器的值保存，在换成`context`中保存的八个值。

`struct trapframe *tf`中保存了中断时线程的相关信息。在中断处理结束后，可以根据这些内容将其恢复。定义如下：

```C
struct trapframe {
    struct pushregs tf_regs;
    uint16_t tf_gs;
    uint16_t tf_padding0;
    uint16_t tf_fs;
    uint16_t tf_padding1;
    uint16_t tf_es;
    uint16_t tf_padding2;
    uint16_t tf_ds;
    uint16_t tf_padding3;
    uint32_t tf_trapno;
    /* below here defined by x86 hardware */
    uint32_t tf_err;
    uintptr_t tf_eip;
    uint16_t tf_cs;
    uint16_t tf_padding4;
    uint32_t tf_eflags;
    /* below here only when crossing rings, such as from user to kernel */
    uintptr_t tf_esp;
    uint16_t tf_ss;
    uint16_t tf_padding5;
} __attribute__((packed));
```

内容分为3部分。第一部分为`tf_regs`到`tf_trapno`，为软件保存的进程各段寄存器值。

第二、第三部分为硬件保存的。第二部分为`tf_err`到`tf_eflags`，为CPU压到栈里的错误码、PC和标志位。第三部分为`tf_esp`和`tf_ss`，当有特权级转换时，CPU也会把栈指针压到栈中。

## 练习二：为新创建的内核线程分配资源



## 本实验知识点



## 本实验中未直接体现的知识点

