# Lab5 Report

计43 高童 2014011357

## 练习零：修改已有实验

**对LAB1的修改：**

在初始化IDT表时，需要加一行，允许用户态进行系统调用，即：

```C
SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
```

每当系统时钟中断达到`TICK_NUM`倍数次时，表示进程时间片用完，需要重新调度，因此加入一行：

```C
current->need_resched = 1;
```

**对LAB4的修改：**

在初始化进程控制块时，要新增初始化内容：

```C
proc->wait_state = 0;
proc->cptr = proc->yptr = proc->optr = NULL;
```

在`do_fork()`函数中，需要设置进程间关系，即需要调用：

```C
set_links(proc);
```

**和`answer`实现的区别：**

在修改LAB1时，由于忘了`SETGATE`宏的定义，将`istrap`参数错写为0。在检查定义后修正。

## 练习一：加载应用程序并执行

在`load_icode()`函数中，在ELF格式程序完全加载入内存后，最后一步操作为设置正确的trapframe，使得用户进程可以返回用户模式，并且从正确的语句开始执行。需要设置的内容包括：

- 代码段寄存器：设置为用户的代码段寄存器（`USER_CS`）；
- 各个数据段寄存器：设置为用户的数据段寄存器（`USER_DS`）；
- 栈寄存器`esp`：设置为用户栈顶（`USTACKTOP`）；
- 指令寄存器`eip`：设置为程序入口（`elf->e_entry`）；
- EFLAGS：设置使能中断（`FL_IF`）。

**和`answer`实现的区别：**

由于实现比较简单，和`answer`没有区别。

**当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的？**

在`load_icode()`函数执行到最后时，用户态应用程序已经加载完毕，trapframe也设置完毕。随后执行return，函数返回`do_execve()`，再次回到上级`sys_exec()`，直至退回到系统调用处理程序最上级，此时执行`iret`。此时会将将段寄存器、`esp`和`eip`根据修改过的trapframe“返回”到用户进程的入口处。再继续执行时，就会开始进行用户态进程。

## 练习二: 父进程复制自己的内存空间给子进程

在`copy_range()`函数中，对原有进程的每个页`page`都新建了一个页`npage`，需要将`page`中的内容复制到`npage`中。需要做的内容有：

1. 找到`page`的虚拟地址；
2. 找到`npage`的虚拟地址；
3. 用`memcpy()`函数复制页的内容；
4. 设置从虚拟地址`start`到物理地址`npage`的映射。

具体实现如下：

```C
void *src_kvaddr = page2kva(page);              // 1
void *dst_kvaddr = page2kva(npage);             // 2
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);         // 3
ret = page_insert(to, npage, start, perm);      // 4
```

**和`answer`实现的区别：**

在一开始的实现中，我没有注意到下方的`assert(ret==0);`语句，没有记录`page_insert()`的返回值`ret`。在查看`answer`后修正。

**如何设计实现“Copy on Write 机制”？**

当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。也就是说，*不进行练习二中的操作*。

当其中任何一个进程修改此用户内存空间中的某页面时， 触发 page fault 异常。此时操作系统可以根据此页的Present位获知这是一个普通的 page fault 还是由COW共享内存造成的异常。如果是后者，则再完成拷贝的功能，并让修改的进程指向修改过的页。

## 本实验知识点



## 本实验中未直接体现的知识点

