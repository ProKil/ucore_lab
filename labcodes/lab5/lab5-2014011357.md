# Lab5 Report

计43 高童 2014011357

## 练习零：修改已有实验

**对LAB1的修改：**

在初始化IDT表时，需要加一行，允许用户态进行系统调用，即：

```C
SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
```

每当系统时钟中断达到`TICK_NUM`倍数次时，表示进程时间片用完，需要重新调度，因此加入一行：

```C
current->need_resched = 1;
```

**对LAB4的修改：**

在初始化进程控制块时，要新增初始化内容：

```C
proc->wait_state = 0;
proc->cptr = proc->yptr = proc->optr = NULL;
```

在`do_fork()`函数中，需要设置进程间关系，即需要调用：

```C
set_links(proc);
```

## 练习一：加载应用程序并执行

在`load_icode()`函数中，在ELF格式程序完全加载入内存后，最后一步操作为设置正确的trapframe，使得用户进程可以返回用户模式，并且从正确的语句开始执行。需要设置的内容包括：

- 代码段寄存器：设置为用户的代码段寄存器（`USER_CS`）；
- 各个数据段寄存器：设置为用户的数据段寄存器（`USER_DS`）；
- 栈寄存器`esp`：设置为用户栈顶（`USTACKTOP`）；
- 指令寄存器`eip`：设置为程序入口（`elf->e_entry`）；
- EFLAGS：设置使能中断（`FL_IF`）。

**和`answer`实现的区别：**

由于实现比较简单，和`answer`没有区别。

**当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的？**

在`load_icode()`函数执行到最后时，用户态应用程序已经加载完毕，trapframe也设置完毕。随后执行return，函数返回`do_execve()`，再次回到上级`sys_exec()`，直至退回到系统调用处理程序最上级，此时执行`iret`。此时会将将段寄存器、`esp`和`eip`根据修改过的trapframe“返回”到用户进程的入口处。再继续执行时，就会开始进行用户态进程。

## 本实验知识点



## 本实验中未直接体现的知识点

