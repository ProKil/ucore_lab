# Lab5 Report

计43 高童 2014011357

## 练习零：修改已有实验

**对LAB1的修改：**

在初始化IDT表时，需要加一行，允许用户态进行系统调用，即：

```C
SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
```

每当系统时钟中断达到`TICK_NUM`倍数次时，表示进程时间片用完，需要重新调度，因此加入一行：

```C
current->need_resched = 1;
```

**对LAB4的修改：**

在初始化进程控制块时，要新增初始化内容：

```C
proc->wait_state = 0;
proc->cptr = proc->yptr = proc->optr = NULL;
```

在`do_fork()`函数中，需要设置进程间关系，即需要调用：

```C
set_links(proc);
```

**和`answer`实现的区别：**

在修改LAB1时，由于忘了`SETGATE`宏的定义，将`istrap`参数错写为0。在检查定义后修正。

## 练习一：加载应用程序并执行

在`load_icode()`函数中，在ELF格式程序完全加载入内存后，最后一步操作为设置正确的trapframe，使得用户进程可以返回用户模式，并且从正确的语句开始执行。需要设置的内容包括：

- 代码段寄存器：设置为用户的代码段寄存器（`USER_CS`）；
- 各个数据段寄存器：设置为用户的数据段寄存器（`USER_DS`）；
- 栈寄存器`esp`：设置为用户栈顶（`USTACKTOP`）；
- 指令寄存器`eip`：设置为程序入口（`elf->e_entry`）；
- EFLAGS：设置使能中断（`FL_IF`）。

**和`answer`实现的区别：**

由于实现比较简单，和`answer`没有区别。

**当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的？**

在`load_icode()`函数执行到最后时，用户态应用程序已经加载完毕，trapframe也设置完毕。随后执行return，函数返回`do_execve()`，再次回到上级`sys_exec()`，直至退回到系统调用处理程序最上级，此时执行`iret`。此时会将将段寄存器、`esp`和`eip`根据修改过的trapframe“返回”到用户进程的入口处。再继续执行时，就会开始进行用户态进程。

## 练习二: 父进程复制自己的内存空间给子进程

在`copy_range()`函数中，对原有进程的每个页`page`都新建了一个页`npage`，需要将`page`中的内容复制到`npage`中。需要做的内容有：

1. 找到`page`的虚拟地址；
2. 找到`npage`的虚拟地址；
3. 用`memcpy()`函数复制页的内容；
4. 设置从虚拟地址`start`到物理地址`npage`的映射。

具体实现如下：

```C
void *src_kvaddr = page2kva(page);              // 1
void *dst_kvaddr = page2kva(npage);             // 2
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);         // 3
ret = page_insert(to, npage, start, perm);      // 4
```

**和`answer`实现的区别：**

在一开始的实现中，我没有注意到下方的`assert(ret==0);`语句，没有记录`page_insert()`的返回值`ret`。在查看`answer`后修正。

**如何设计实现“Copy on Write 机制”？**

当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。也就是说，*不进行练习二中的操作*。

当其中任何一个进程修改此用户内存空间中的某页面时， 触发 page fault 异常。此时操作系统可以根据此页的Present位获知这是一个普通的 page fault 还是由COW共享内存造成的异常。如果是后者，则再完成拷贝的功能，并让修改的进程指向修改过的页。

## 练习三：理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

**fork操作：**

在`do_fork()`函数中，操作系统先给新进程分配相关空间，随后调用`copy_thread()`函数设置trapframe相关信息，之后将新进程加入进程列表，最后唤醒进程，使之可被调度。

**fork如何影响进程状态？**

在fork完成后，会调用`wakeup_proc()`函数将其状态设为`PROC_RUNNABLE`。

**exec操作：**

在`do_execve()`函数中，首先要做的是把上一个进程的相关信息抹去，以运行自己的程序。具体来说，就是把`mm`指向的内存空间收回。随后，调用`load_icode()`函数将ELF格式的程序载入内存中。最后，将进程名设置为正确的名字。

**exec如何影响进程状态？**

在exec中，会选择当前进程进入运行态。

**wait操作：**

首先，函数根据`pid`寻找当前进程的子进程。如果找到子进程，但子进程不是`PROC_ZOMBIE`状态，则将当前进程状态设为`SLEEPING`，将`wait_state`设置为`WT_CHILD`，随后调度，让其他进程执行。如果子进程已经是`PROC_ZOMBIE`状态，则保存子进程的返回值后，将子进程空间完全收回。

**wait如何影响进程状态？**

如果有子进程不在僵尸状态，则会将当前进程设置为睡眠状态；如果在，则会退出此子进程。

**exit操作：**

首先，和exec操作类似，需要把`mm`指向的内存空间收回。随后，将进程状态设置为`PROC_ZOMBIE`。然后检查父进程状态，如果`wait_state`设置为`WT_CHILD`，则唤醒父进程，将其返回值返回。与此同时，需要把此进程从父进程的子进程列表中删除。最后，调用`schedule()`重新调度进程。

**exit如何影响进程状态？**

会将当前子进程设置为僵尸状态，方便后续父进程回收。

**系统调用：**

系统调用使用`syscall()`函数。具体实现直接由汇编实现，通过执行`int 0x80`，再从栈上获得相应的系统调用代码和参数获得系统调用详情。CPU在查询中断描述符表`0x80`项后，分别经过函数`trap()`到`trap_dispatch()`到`syscall()`到具体的系统调用处理函数。处理结束后，通过调用`iret`回到需要回到的地方。

**用户态进程的执行状态生命周期图？**

```
       fork()          exit()
UNINIT------->RUNNABLE------->ZOMBIE
                |  ^
         wait() |  | wakeup_proc()
                V  |
              SLEEPING
```

## 本实验知识点

- 用户进程创建过程
- 系统调用框架的实现机制
- 系统调用sys_fork/sys_exec/sys_exit/sys_wait的进程管理

## 本实验中未直接体现的知识点

- 轻权线程
- 进程调度
- 进程的“挂起”状态