# Lab7 Report

计43 高童 2014011357

## 练习零：修改已有实验

**对LAB1的修改：**

每当系统时钟时，需要调用调度程序的`run_timer_list()`函数，让调度程序检查所有计时器的计时情况并处理，最后处理进程自己的计时信息。因此在处理时钟中断时改为：

```C
run_timer_list();
```

由于此函数会调用`sched_class_proc_tick()`静态函数，因此在此处删去原来自己定义的`my_sched_class_proc_tick()`函数。

**和`answer`实现的区别：**

由于实现简单，和`answer`没有区别。

## 练习一：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

**内核级信号量的设计描述：**

内核级信号量的定义为：

```C
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```

`value`表示信号量值，另外还有一个进程等待队列`wait_queue`。

**P操作**的实现为`down()`，具体流程如下：

1. 进入临界区。
   1. 如果信号量值大于零，则将之减一，退出临界区，返回即可。
2. 设置当前进程状态为`PROC_SLEEPING`，其等待状态为`WT_KSEM`，加入信号量的等待队列。
3. 退出临界区，调用`schedule()`，将控制权转移出去。
4. 在`schedule()`返回后，将其从信号量的等待队列中删去。
5. 检查进程的等待状态，如果为`WT_KSEM`，则正确返回。

**V操作**的实现为`up()`，具体流程如下：

1. 检查等待队列是否为空。
   1. 如果为空，则直接将信号量值加一，返回即可。
2. 如果不为空，将等待队列中的第一个进程唤醒。

**给用户态进程/线程提供信号量机制的设计方案：**

用户态进程不能直接调用内核函数，需要设置新的系统调用。需要设计接口，通过系统调用完成P操作和V操作。

## 本实验知识点



## 本实验中未直接体现的知识点

